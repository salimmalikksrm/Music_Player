<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vanilla JS Music Player</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet" />
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
        }
        /* Custom scrollbar for playlist */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #333;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #8B5CF6; /* purple-500 */
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #7C3AED; /* purple-600 */
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-purple-800 to-indigo-900 text-white font-inter p-4 flex flex-col items-center justify-center">
    <div class="w-full max-w-md bg-gray-900 rounded-3xl shadow-2xl p-6 space-y-6 transform transition-all duration-300 hover:scale-105">
        <h1 class="text-4xl font-extrabold text-center text-purple-300 mb-6 drop-shadow-lg">
            Music Player
        </h1>

        <!-- Error Message Display -->
        <div id="errorMessage" class="hidden bg-red-600 text-white p-3 rounded-xl text-center font-semibold animate-pulse"></div>

        <!-- Audio Element -->
        <audio id="audioPlayer"></audio>

        <!-- Current Track Display -->
        <div class="text-center mb-4">
            <p id="currentTrackName" class="text-xl font-semibold text-purple-200">No track selected</p>
            <p class="text-sm text-gray-400">
                <span id="currentTime">00:00</span> / <span id="duration">00:00</span>
            </p>
        </div>

        <!-- Playback Controls -->
        <div class="flex items-center justify-center space-x-4 mb-6">
            <!-- Shuffle button removed -->
            <button id="rewind10Btn"
                class="relative p-3 bg-purple-700 hover:bg-purple-600 rounded-full shadow-lg transition-all duration-200 transform hover:scale-110 focus:outline-none focus:ring-4 focus:ring-purple-500"
                aria-label="Rewind 10 seconds">
                <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                </svg>
                <span class="absolute text-xs -mt-1 -ml-1 top-1 left-1/2 -translate-x-1/2 text-white font-bold">10</span>
            </button>
            <button id="prevBtn"
                class="p-4 bg-purple-700 hover:bg-purple-600 rounded-full shadow-lg transition-all duration-200 transform hover:scale-110 focus:outline-none focus:ring-4 focus:ring-purple-500"
                aria-label="Previous Track">
                <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                </svg>
            </button>
            <button id="playPauseBtn"
                class="p-4 bg-purple-500 hover:bg-purple-400 rounded-full shadow-xl transition-all duration-200 transform hover:scale-110 focus:outline-none focus:ring-4 focus:ring-purple-300"
                aria-label="Play/Pause">
                <svg id="playIcon" class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                </svg>
                <svg id="pauseIcon" class="w-8 h-8 text-white hidden" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zM7 8a1 1 0 012 0v4a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v4a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" />
                </svg>
            </button>
            <button id="nextBtn"
                class="p-4 bg-purple-700 hover:bg-purple-600 rounded-full shadow-lg transition-all duration-200 transform hover:scale-110 focus:outline-none focus:ring-4 focus:ring-purple-500"
                aria-label="Next Track">
                <svg class="w-8 h-8 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM10.445 7.168A1 1 0 0112 8v4a1 1 0 01-1.555.832l3-2a1 1 0 010-1.664l3-2z" clip-rule="evenodd" />
                </svg>
            </button>
            <button id="forward10Btn"
                class="relative p-3 bg-purple-700 hover:bg-purple-600 rounded-full shadow-lg transition-all duration-200 transform hover:scale-110 focus:outline-none focus:ring-4 focus:ring-purple-500"
                aria-label="Forward 10 seconds">
                <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM10.445 7.168A1 1 0 0112 8v4a1 1 0 01-1.555.832l3-2a1 1 0 010-1.664l3-2z" clip-rule="evenodd" />
                </svg>
                <span class="absolute text-xs -mt-1 -ml-1 top-1 left-1/2 -translate-x-1/2 text-white font-bold">10</span>
            </button>
            <button id="repeatBtn"
                class="relative p-3 bg-purple-700 hover:bg-purple-600 rounded-full shadow-lg transition-all duration-200 transform hover:scale-110 focus:outline-none focus:ring-4 focus:ring-purple-500"
                aria-label="Repeat Mode">
                <svg class="w-6 h-6 text-white" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM7 7a1 1 0 011-1h4a1 1 0 011 1v2a1 1 0 11-2 0V8h-2v4h2a1 1 0 110 2H8a1 1 0 01-1-1V7z" clip-rule="evenodd" />
                </svg>
                <span id="repeatIndicator" class="absolute text-xs -mt-1 -ml-1 text-yellow-300 font-bold top-1 left-1/2 -translate-x-1/2"></span>
            </button>
        </div>

        <!-- Progress Bar -->
        <input type="range" id="progressBar" min="0" value="0"
            class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-purple-500" />

        <!-- Volume Control -->
        <div class="flex items-center space-x-3 mt-4">
            <svg class="w-6 h-6 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path fill-rule="evenodd" d="M9.383 3.095A1 1 0 0110 4v12a1 1 0 01-1.707.707L4.586 13H2a1 1 0 01-1-1V8a1 1 0 011-1h2.586l3.707-3.707a1 1 0 011.09-.2zM14.5 7.636a4.995 4.995 0 010 4.728V7.636zM16.727 5.409a7.995 7.995 0 010 9.182V5.409z" clip-rule="evenodd" />
            </svg>
            <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="0.7"
                class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-purple-500" />
        </div>

        <!-- File and URL Loading -->
        <div class="mt-6 space-y-4">
            <label for="fileInput" class="block text-sm font-medium text-gray-300">Load Music from Device:</label>
            <input type="file" id="fileInput" accept="audio/*,.mp3,.wav,.ogg,.flac,.aac" multiple
                class="block w-full text-sm text-gray-300
                       file:mr-4 file:py-2 file:px-4
                       file:rounded-full file:border-0
                       file:text-sm file:font-semibold
                       file:bg-purple-500 file:text-white
                       hover:file:bg-purple-600 cursor-pointer rounded-xl" />

            <label for="urlInput" class="block text-sm font-medium text-gray-300 mt-4">Load Music from URL:</label>
            <div class="flex space-x-2">
                <input type="text" id="urlInput" placeholder="e.g., https://example.com/song.mp3"
                    class="flex-grow p-2 rounded-xl bg-gray-800 border border-gray-700 text-white placeholder-gray-500 focus:ring-purple-500 focus:border-purple-500" />
                <button id="loadUrlBtn"
                    class="px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white font-semibold rounded-xl shadow-md transition-all duration-200 transform hover:scale-105">
                    Load URL
                </button>
            </div>
            <p class="text-xs text-gray-400 mt-1">
                To load from GitHub: Navigate to your audio file on GitHub, click "Raw", and copy that URL.
            </p>
        </div>

        <!-- Playlist Display -->
        <div class="mt-6">
            <h2 class="text-xl font-bold text-purple-300 mb-3">Playlist</h2>
            <ul id="playlist" class="space-y-2 max-h-48 overflow-y-auto custom-scrollbar p-2 rounded-xl bg-gray-800">
                <p id="emptyPlaylistMessage" class="text-gray-400 text-center">No songs in playlist. Add some!</p>
            </ul>
        </div>
    </div>

    <script>
        // DOM Elements
        const audioPlayer = document.getElementById('audioPlayer');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const playIcon = document.getElementById('playIcon');
        const pauseIcon = document.getElementById('pauseIcon');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const progressBar = document.getElementById('progressBar');
        const volumeControl = document.getElementById('volumeControl');
        const currentTrackName = document.getElementById('currentTrackName');
        const currentTimeDisplay = document.getElementById('currentTime');
        const durationDisplay = document.getElementById('duration');
        const fileInput = document.getElementById('fileInput');
        const urlInput = document.getElementById('urlInput');
        const loadUrlBtn = document.getElementById('loadUrlBtn');
        const playlistElement = document.getElementById('playlist');
        const emptyPlaylistMessage = document.getElementById('emptyPlaylistMessage');
        const errorMessageDisplay = document.getElementById('errorMessage');

        // New DOM Elements for added features
        const rewind10Btn = document.getElementById('rewind10Btn');
        const forward10Btn = document.getElementById('forward10Btn');
        const repeatBtn = document.getElementById('repeatBtn');
        const repeatIndicator = document.getElementById('repeatIndicator');

        // State variables
        let playlist = [];
        let originalPlaylist = []; // To store original order for shuffle (still kept for potential future use or if user changes mind)
        let currentTrackIndex = 0;
        let isPlaying = false;
        let repeatMode = 0; // 0: no repeat, 1: repeat all, 2: repeat one

        // Function to display error messages
        function showErrorMessage(message) {
            errorMessageDisplay.textContent = message;
            errorMessageDisplay.classList.remove('hidden');
            setTimeout(() => {
                errorMessageDisplay.classList.add('hidden');
            }, 5000); // Hide after 5 seconds
        }

        // Function to format time (MM:SS)
        function formatTime(time) {
            const minutes = Math.floor(time / 60);
            const seconds = Math.floor(time % 60);
            return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Function to update UI for play/pause state
        function updatePlayPauseUI() {
            if (isPlaying) {
                playIcon.classList.add('hidden');
                pauseIcon.classList.remove('hidden');
            } else {
                playIcon.classList.remove('hidden');
                pauseIcon.classList.add('hidden');
            }
            updateMediaSessionState(); // Update Media Session when play/pause changes
        }

        // Function to update repeat mode UI
        function updateRepeatUI() {
            switch (repeatMode) {
                case 0:
                    repeatIndicator.textContent = ''; // No indicator
                    repeatBtn.classList.remove('text-yellow-300'); // Remove highlight
                    break;
                case 1:
                    repeatIndicator.textContent = 'All'; // Repeat all
                    repeatBtn.classList.add('text-yellow-300'); // Add highlight
                    break;
                case 2:
                    repeatIndicator.textContent = 'One'; // Repeat one
                    repeatBtn.classList.add('text-yellow-300'); // Add highlight
                    break;
            }
            updateMediaSessionState(); // Update Media Session when repeat mode changes
        }

        // Function to render the playlist
        function renderPlaylist() {
            playlistElement.innerHTML = ''; // Clear existing list
            if (playlist.length === 0) {
                emptyPlaylistMessage.classList.remove('hidden');
                playlistElement.appendChild(emptyPlaylistMessage);
            } else {
                emptyPlaylistMessage.classList.add('hidden');
                playlist.forEach((track, index) => {
                    const listItem = document.createElement('li');
                    listItem.classList.add('p-3', 'rounded-xl', 'cursor-pointer', 'transition-all', 'duration-200', 'flex', 'items-center', 'justify-between');
                    listItem.textContent = `${index + 1}. ${track.name}`;

                    if (index === currentTrackIndex) {
                        listItem.classList.add('bg-purple-700', 'text-white', 'shadow-lg', 'font-bold');
                        if (isPlaying) {
                            const playingIcon = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                            playingIcon.classList.add('w-5', 'h-5', 'text-green-400', 'animate-pulse');
                            playingIcon.setAttribute('fill', 'currentColor');
                            playingIcon.setAttribute('viewBox', '0 0 20 20');
                            playingIcon.innerHTML = '<path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />';
                            listItem.appendChild(playingIcon);
                        }
                    } else {
                        listItem.classList.add('bg-gray-700', 'text-gray-200', 'hover:bg-gray-600');
                    }

                    listItem.addEventListener('click', () => playTrack(index));
                    playlistElement.appendChild(listItem);
                });
            }
        }

        // Function to play a specific track
        function playTrack(index) {
            if (playlist.length === 0) {
                showErrorMessage('No tracks in the playlist.');
                return;
            }
            if (index < 0 || index >= playlist.length) {
                showErrorMessage('Invalid track index.');
                return;
            }

            currentTrackIndex = index;
            const newSrc = playlist[currentTrackIndex].src;

            // Only update source and load if the source has actually changed
            if (audioPlayer.src !== newSrc) {
                audioPlayer.src = newSrc;
                audioPlayer.load(); // This resets playback to start
            }

            audioPlayer.play()
                .then(() => {
                    isPlaying = true;
                    updatePlayPauseUI();
                    currentTrackName.textContent = playlist[currentTrackIndex].name;
                    showErrorMessage(''); // Clear error on successful play
                    renderPlaylist(); // Re-render to highlight current track
                    updateMediaSessionMetadata(); // Update Media Session metadata
                })
                .catch(error => {
                    console.error("Error playing audio:", error);
                    showErrorMessage("Failed to play audio. Please check the file or URL. (User interaction may be required to start playback)");
                    isPlaying = false;
                    updatePlayPauseUI();
                    renderPlaylist(); // Re-render to update playing icon
                });
        }

        // Function to seek forward/backward
        function seek(seconds) {
            if (audioPlayer.src) {
                audioPlayer.currentTime = Math.max(0, Math.min(audioPlayer.duration, audioPlayer.currentTime + seconds));
                updateMediaSessionState(); // Update Media Session position
            }
        }

        // Function to shuffle the playlist (kept for reference, but not used by button)
        function shufflePlaylist() {
            if (playlist.length <= 1) return;

            // If playlist is already shuffled, revert to original
            if (playlist === originalPlaylist) {
                playlist = [...originalPlaylist]; // Create a copy
            } else {
                // Store original playlist if not already stored
                if (originalPlaylist.length === 0 || originalPlaylist.length !== playlist.length || !playlist.every((val, i) => val === originalPlaylist[i])) {
                    originalPlaylist = [...playlist];
                }

                // Fisher-Yates (Knuth) shuffle algorithm
                for (let i = playlist.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [playlist[i], playlist[j]] = [playlist[j], playlist[i]];
                }
            }

            // If a track was playing, find its new index and play it
            if (isPlaying && audioPlayer.src) {
                const currentSrc = audioPlayer.src;
                const newIndex = playlist.findIndex(track => track.src === currentSrc);
                if (newIndex !== -1) {
                    currentTrackIndex = newIndex;
                } else {
                    currentTrackIndex = 0; // Fallback if current track not found (shouldn't happen)
                }
            } else {
                currentTrackIndex = 0; // If nothing was playing, reset to first track
            }

            renderPlaylist();
            showErrorMessage('Playlist shuffled!');
        }

        // Function to toggle repeat mode
        function toggleRepeat() {
            repeatMode = (repeatMode + 1) % 3; // Cycle through 0, 1, 2
            updateRepeatUI();
            let message = '';
            switch (repeatMode) {
                case 0: message = 'Repeat: Off'; break;
                case 1: message = 'Repeat: All'; break;
                case 2: message = 'Repeat: One'; break;
            }
            showErrorMessage(message);
        }

        // Media Session API functions
        function setupMediaSession() {
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => {
                    if (audioPlayer.paused) {
                        playPauseBtn.click(); // Simulate click on our play/pause button
                    }
                });
                navigator.mediaSession.setActionHandler('pause', () => {
                    if (!audioPlayer.paused) {
                        playPauseBtn.click(); // Simulate click on our play/pause button
                    }
                });
                navigator.mediaSession.setActionHandler('previoustrack', () => {
                    prevBtn.click(); // Simulate click on our previous button
                });
                navigator.mediaSession.setActionHandler('nexttrack', () => {
                    nextBtn.click(); // Simulate click on our next button
                });
                // Optional: Add seek handlers for finer control
                navigator.mediaSession.setActionHandler('seekbackward', (event) => {
                    const seekTime = event.seekOffset || 10; // Default 10 seconds
                    seek(-seekTime);
                });
                navigator.mediaSession.setActionHandler('seekforward', (event) => {
                    const seekTime = event.seekOffset || 10; // Default 10 seconds
                    seek(seekTime);
                });
                navigator.mediaSession.setActionHandler('seekto', (event) => {
                    if (audioPlayer.duration) {
                        audioPlayer.currentTime = event.seekTime;
                        updateMediaSessionState();
                    }
                });
            }
        }

        function updateMediaSessionMetadata() {
            if ('mediaSession' in navigator && playlist.length > 0) {
                const currentTrack = playlist[currentTrackIndex];
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: currentTrack.name,
                    artist: 'Music Player', // You can customize this
                    album: 'My Playlist', // You can customize this
                    // artwork: [
                    //     { src: 'path/to/96x96.png', sizes: '96x96', type: 'image/png' },
                    //     { src: 'path/to/128x128.png', sizes: '128x128', type: 'image/png' },
                    //     // ... other sizes
                    // ]
                });
            }
        }

        function updateMediaSessionState() {
            if ('mediaSession' in navigator && audioPlayer.src) {
                navigator.mediaSession.playbackState = isPlaying ? 'playing' : 'paused';
                navigator.mediaSession.setPositionState({
                    duration: audioPlayer.duration,
                    playbackRate: audioPlayer.playbackRate,
                    position: audioPlayer.currentTime
                });
            }
        }


        // Event Listeners
        playPauseBtn.addEventListener('click', () => {
            if (playlist.length === 0) {
                showErrorMessage('Add music to the playlist first!');
                return;
            }
            if (isPlaying) {
                audioPlayer.pause();
                isPlaying = false;
            } else {
                if (audioPlayer.paused && audioPlayer.src) {
                    audioPlayer.play()
                        .then(() => {
                            isPlaying = true;
                            showErrorMessage('');
                        })
                        .catch(error => {
                            console.error("Error resuming audio:", error);
                            showErrorMessage("Failed to resume audio. (User interaction may be required)");
                            isPlaying = false;
                        });
                } else if (playlist.length > 0) {
                    playTrack(currentTrackIndex);
                }
            }
            updatePlayPauseUI();
            renderPlaylist();
        });

        prevBtn.addEventListener('click', () => {
            if (playlist.length > 0) {
                currentTrackIndex = (currentTrackIndex - 1 + playlist.length) % playlist.length;
                playTrack(currentTrackIndex);
            }
        });

        nextBtn.addEventListener('click', () => {
            if (playlist.length > 0) {
                // Handle repeat one mode
                if (repeatMode === 2) {
                    playTrack(currentTrackIndex); // Replay current track
                } else {
                    currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
                    playTrack(currentTrackIndex);
                }
            }
        });

        rewind10Btn.addEventListener('click', () => seek(-10));
        forward10Btn.addEventListener('click', () => seek(10));
        repeatBtn.addEventListener('click', toggleRepeat);

        audioPlayer.addEventListener('timeupdate', () => {
            progressBar.value = audioPlayer.currentTime;
            currentTimeDisplay.textContent = formatTime(audioPlayer.currentTime);
            updateMediaSessionState(); // Update Media Session position
        });

        audioPlayer.addEventListener('loadedmetadata', () => {
            progressBar.max = audioPlayer.duration;
            durationDisplay.textContent = formatTime(audioPlayer.duration);
            updateMediaSessionMetadata(); // Update Media Session metadata
            updateMediaSessionState(); // Update Media Session state (duration, etc.)
        });

        audioPlayer.addEventListener('ended', () => {
            if (playlist.length > 0) {
                if (repeatMode === 2) { // Repeat one
                    playTrack(currentTrackIndex);
                } else if (repeatMode === 1) { // Repeat all
                    currentTrackIndex = (currentTrackIndex + 1) % playlist.length;
                    playTrack(currentTrackIndex);
                } else { // No repeat
                    if (currentTrackIndex < playlist.length - 1) {
                        currentTrackIndex++;
                        playTrack(currentTrackIndex);
                    } else {
                        isPlaying = false;
                        updatePlayPauseUI();
                        currentTrackName.textContent = 'No track selected';
                        currentTimeDisplay.textContent = '00:00';
                        durationDisplay.textContent = '00:00';
                        progressBar.value = 0;
                        renderPlaylist();
                    }
                }
            } else {
                isPlaying = false;
                updatePlayPauseUI();
                currentTrackName.textContent = 'No track selected';
                currentTimeDisplay.textContent = '00:00';
                durationDisplay.textContent = '00:00';
                progressBar.value = 0;
                renderPlaylist();
            }
        });

        audioPlayer.addEventListener('error', (e) => {
            console.error("Audio element error:", e);
            showErrorMessage("Error loading or playing audio. Check URL/file format.");
            isPlaying = false;
            updatePlayPauseUI();
            renderPlaylist();
        });

        volumeControl.addEventListener('input', (e) => {
            audioPlayer.volume = parseFloat(e.target.value);
        });

        progressBar.addEventListener('input', (e) => {
            audioPlayer.currentTime = parseFloat(e.target.value);
        });

        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            const newTracks = files.map(file => ({
                name: file.name,
                src: URL.createObjectURL(file)
            }));
            playlist = [...playlist, ...newTracks];
            originalPlaylist = [...playlist]; // Update original playlist
            if (playlist.length === newTracks.length) { // If this was the first batch of songs
                playTrack(0);
            }
            renderPlaylist();
            showErrorMessage('');
        });

        loadUrlBtn.addEventListener('click', () => {
            const url = urlInput.value.trim();
            if (url === '') {
                showErrorMessage('Please enter a valid URL.');
                return;
            }
            const newTrack = {
                name: url.substring(url.lastIndexOf('/') + 1) || 'Unknown Track',
                src: url
            };
            playlist = [...playlist, newTrack];
            originalPlaylist = [...playlist]; // Update original playlist
            if (playlist.length === 1) { // If this is the first song added
                playTrack(0);
            }
            renderPlaylist();
            urlInput.value = ''; // Clear the input
            showErrorMessage('');
        });

        // Initial setup on page load
        document.addEventListener('DOMContentLoaded', () => {
            audioPlayer.volume = volumeControl.value; // Set initial volume
            renderPlaylist(); // Render playlist on load
            updateRepeatUI(); // Initialize repeat UI
            setupMediaSession(); // Setup Media Session API handlers
            // Register service worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw.js') // Path to your service worker file
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            }
        });
    </script>
</body>
</html>
